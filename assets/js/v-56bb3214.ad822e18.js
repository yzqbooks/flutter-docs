"use strict";(self.webpackChunkflutter_docs=self.webpackChunkflutter_docs||[]).push([[249],{29480:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e=JSON.parse('{"key":"v-56bb3214","path":"/chapter2/flutter_widget_intro.html","title":"2.2  Widget 简介","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"2.2.1 Widget 概念","slug":"_2-2-1-widget-概念","link":"#_2-2-1-widget-概念","children":[]},{"level":2,"title":"2.2.2  Widget 接口","slug":"_2-2-2-widget-接口","link":"#_2-2-2-widget-接口","children":[]},{"level":2,"title":"2.2.3 Flutter中的四棵树","slug":"_2-2-3-flutter中的四棵树","link":"#_2-2-3-flutter中的四棵树","children":[]},{"level":2,"title":"2.2.4 StatelessWidget","slug":"_2-2-4-statelesswidget","link":"#_2-2-4-statelesswidget","children":[{"level":3,"title":"Context","slug":"context","link":"#context","children":[]}]},{"level":2,"title":"2.2.5 StatefulWidget","slug":"_2-2-5-statefulwidget","link":"#_2-2-5-statefulwidget","children":[]},{"level":2,"title":"2.2.6 State","slug":"_2-2-6-state","link":"#_2-2-6-state","children":[]},{"level":2,"title":"2.2.7 在 widget 树中获取State对象","slug":"_2-2-7-在-widget-树中获取state对象","link":"#_2-2-7-在-widget-树中获取state对象","children":[{"level":3,"title":"通过Context获取","slug":"通过context获取","link":"#通过context获取","children":[]},{"level":3,"title":"通过GlobalKey","slug":"通过globalkey","link":"#通过globalkey","children":[]}]},{"level":2,"title":"2.2.8 通过 RenderObject 自定义 Widget","slug":"_2-2-8-通过-renderobject-自定义-widget","link":"#_2-2-8-通过-renderobject-自定义-widget","children":[]},{"level":2,"title":"2.2.9 Flutter SDK内置组件库介绍","slug":"_2-2-9-flutter-sdk内置组件库介绍","link":"#_2-2-9-flutter-sdk内置组件库介绍","children":[{"level":3,"title":"关于示例","slug":"关于示例","link":"#关于示例","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1654491188000,"updatedTime":1654491188000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":1}]},"readingTime":{"minutes":21.38,"words":6415},"filePathRelative":"chapter2/flutter_widget_intro.md","localizedDate":"2022年6月6日","excerpt":""}')},67199:(n,s,a)=>{a.r(s),a.d(s,{default:()=>z});var e=a(6808);const t=a.p+"assets/img/2-2.8f9b6f72.png",p=a.p+"assets/img/2-3.9e8b538f.png",c=a.p+"assets/img/2-4.858b091f.png",o=a.p+"assets/img/2-5.c2292aa8.jpg",l=a.p+"assets/img/2-6.d9c0c5f8.png",i=a.p+"assets/img/2-7.891465ec.png",u=(0,e.uE)('<h1 id="_2-2-widget-简介" tabindex="-1"><a class="header-anchor" href="#_2-2-widget-简介" aria-hidden="true">#</a> 2.2 Widget 简介</h1><h2 id="_2-2-1-widget-概念" tabindex="-1"><a class="header-anchor" href="#_2-2-1-widget-概念" aria-hidden="true">#</a> 2.2.1 Widget 概念</h2><p>在前面的介绍中，我们知道在Flutter中几乎所有的对象都是一个 widget 。与原生开发中“控件”不同的是，Flutter 中的 widget 的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 <code>GestureDetector</code> 、用于APP主题数据传递的 <code>Theme</code> 等等，而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是 widget ，只是在不同场景的不同表述而已。由于 Flutter 主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为 widget 就是一个控件，不必纠结于概念。</p><p>Flutter 中是通过 Widget 嵌套 Widget 的方式来构建UI和进行实践处理的，所以记住，Flutter 中万物皆为Widget。</p><h2 id="_2-2-2-widget-接口" tabindex="-1"><a class="header-anchor" href="#_2-2-2-widget-接口" aria-hidden="true">#</a> 2.2.2 Widget 接口</h2><p>在 Flutter 中， widget 的功能是“描述一个UI元素的配置信息”，它就是说， Widget 其实并不是表示最终绘制在设备屏幕上的显示元素，所谓的配置信息就是 Widget 接收的参数，比如对于 Text 来讲，文本的内容、对齐方式、文本样式都是它的配置信息。下面我们先来看一下 Widget 类的声明：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token metadata function">@immutable</span> <span class="token comment">// 不可变的</span>\n<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token keyword">extends</span> <span class="token class-name">DiagnosticableTree</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token class-name">Widget</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">final</span> <span class="token class-name">Key</span><span class="token operator">?</span> key<span class="token punctuation">;</span>\n\n  <span class="token metadata function">@protected</span>\n  <span class="token metadata function">@factory</span>\n  <span class="token class-name">Element</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">String</span> <span class="token function">toStringShort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">final</span> <span class="token class-name">String</span> type <span class="token operator">=</span> <span class="token function">objectRuntimeType</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&#39;Widget&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> type <span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&#39;</span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">type</span></span><span class="token string">-</span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">key</span></span><span class="token string">&#39;</span></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">debugFillProperties</span><span class="token punctuation">(</span><span class="token class-name">DiagnosticPropertiesBuilder</span> properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">debugFillProperties</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    properties<span class="token punctuation">.</span>defaultDiagnosticsTreeStyle <span class="token operator">=</span> <span class="token class-name">DiagnosticsTreeStyle</span><span class="token punctuation">.</span>dense<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token metadata function">@nonVirtual</span>\n  bool <span class="token keyword">operator</span> <span class="token operator">==</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">super</span> <span class="token operator">==</span> other<span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token metadata function">@nonVirtual</span>\n  int <span class="token keyword">get</span> hashCode <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">super</span><span class="token punctuation">.</span>hashCode<span class="token punctuation">;</span>\n\n  <span class="token keyword">static</span> bool <span class="token function">canUpdate</span><span class="token punctuation">(</span><span class="token class-name">Widget</span> oldWidget<span class="token punctuation">,</span> <span class="token class-name">Widget</span> newWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> oldWidget<span class="token punctuation">.</span>runtimeType <span class="token operator">==</span> newWidget<span class="token punctuation">.</span>runtimeType\n        <span class="token operator">&amp;&amp;</span> oldWidget<span class="token punctuation">.</span>key <span class="token operator">==</span> newWidget<span class="token punctuation">.</span>key<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>@immutable</code> 代表 Widget 是不可变的，这会限制 Widget 中定义的属性（即配置信息）必须是不可变的（final），为什么不允许 Widget 中定义的属性变化呢？这是因为，Flutter 中如果属性发生变化则会重新构建Widget树，即重新创建新的 Widget 实例来替换旧的 Widget 实例，所以允许 Widget 的属性变化是没有意义的，因为一旦 Widget 自己的属性变了自己就会被替换。这也是为什么 Widget 中定义的属性必须是 final 的原因。</li><li><code>widget</code>类继承自<code>DiagnosticableTree</code>，<code>DiagnosticableTree</code>即“诊断树”，主要作用是提供调试信息。</li><li><code>Key</code>: 这个<code>key</code>属性类似于 React/Vue 中的<code>key</code>，主要的作用是决定是否在下一次<code>build</code>时复用旧的 widget ，决定的条件在<code>canUpdate()</code>方法中。</li><li><code>createElement()</code>：正如前文所述“一个 widget 可以对应多个<code>Element</code>”；Flutter 框架在构建UI树时，会先调用此方法生成对应节点的<code>Element</code>对象。此方法是 Flutter 框架隐式调用的，在我们开发过程中基本不会调用到。</li><li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li><li><code>canUpdate(...)</code>是一个静态方法，它主要用于在 widget 树重新<code>build</code>时复用旧的 widget ，其实具体来说，应该是：是否用新的 widget 对象去更新旧UI树上所对应的<code>Element</code>对象的配置；通过其源码我们可以看到，只要<code>newWidget </code>与<code>oldWidget </code>的<code>runtimeType</code>和<code>key</code>同时相等时就会用<code>new widget </code>去更新<code>Element</code>对象的配置，否则就会创建新的<code>Element</code>。</li></ul><p>有关 Key 和 widget 复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为 widget 显式添加 key 的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数，本书后面在用到时会详细解释 。</p><p>另外<code>Widget</code>类本身是一个抽象类，其中最核心的就是定义了<code>createElement()</code>接口，在 Flutter 开发中，我们一般都不用直接继承<code>Widget</code>类来实现一个新组件，相反，我们通常会通过继承<code>StatelessWidget </code>或<code>StatefulWidget </code>来间接继承<code>widget</code>类来实现。<code>StatelessWidget </code>和<code>StatefulWidget </code>都是直接继承自<code>Widget</code>类，而这两个类也正是 Flutter 中非常重要的两个抽象类，它们引入了两种 widget 模型，接下来我们将重点介绍一下这两个类。</p><h2 id="_2-2-3-flutter中的四棵树" tabindex="-1"><a class="header-anchor" href="#_2-2-3-flutter中的四棵树" aria-hidden="true">#</a> 2.2.3 Flutter中的四棵树</h2><p>既然 Widget 只是描述一个UI元素的配置信息，那么真正的布局、绘制是由谁来完成的呢？Flutter 框架的的处理流程是这样的：</p><ol><li>根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 <code>Element</code> 类。</li><li>根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自<code> RenderObject</code> 类。</li><li>根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 <code>Layer</code> 类。</li></ol><p>真正的布局和渲染逻辑在 Render 树中，Element 是 Widget 和 RenderObject 的粘合剂，可以理解为一个中间代理。我们通过一个例子来说明，假设有如下 Widget 树：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token class-name">Container</span><span class="token punctuation">(</span> <span class="token comment">// 一个容器 widget</span>\n  color<span class="token punctuation">:</span> <span class="token class-name">Colors</span><span class="token punctuation">.</span>blue<span class="token punctuation">,</span> <span class="token comment">// 设置容器背景色</span>\n  child<span class="token punctuation">:</span> <span class="token class-name">Row</span><span class="token punctuation">(</span> <span class="token comment">// 可以将子widget沿水平方向排列</span>\n    children<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token class-name">Image</span><span class="token punctuation">.</span><span class="token function">network</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;https://www.example.com/1.png&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 显示图片的 widget</span>\n      <span class="token keyword">const</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;A&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，如果 Container 设置了背景色，Container 内部会创建一个新的 ColoredBox 来填充背景，相关逻辑如下：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n  current <span class="token operator">=</span> <span class="token class-name">ColoredBox</span><span class="token punctuation">(</span>color<span class="token punctuation">:</span> color<span class="token operator">!</span><span class="token punctuation">,</span> child<span class="token punctuation">:</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>而 Image 内部会通过 RawImage 来渲染图片、Text 内部会通过 RichText 来渲染文本，所以最终的 Widget树、Element 树、渲染树结构如图2-2所示：</p><p><img src="'+t+'" alt="图2-2"></p><p>这里需要注意：</p><ol><li>三棵树中，Widget 和 Element 是一一对应的，但并不和 RenderObject 一一对应。比如 <code>StatelessWidget</code> 和 <code>StatefulWidget</code> 都没有对应的 RenderObject。</li><li>渲染树在上屏前会生成一棵 Layer 树，这个我们将在后面原理篇介绍，在前面的章节中读者只需要记住以上三棵树就行。</li></ol><h2 id="_2-2-4-statelesswidget" tabindex="-1"><a class="header-anchor" href="#_2-2-4-statelesswidget" aria-hidden="true">#</a> 2.2.4 StatelessWidget</h2><p>在之前的章节中，我们已经简单介绍过<code>StatelessWidget </code>，<code>StatelessWidget </code>相对比较简单，它继承自<code>widget</code>类，重写了<code>createElement() </code>方法：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token metadata function">@override</span>\n<span class="token class-name">StatelessElement</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">StatelessElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>StatelessElement</code> 间接继承自<code>Element</code>类，与<code>StatelessWidget </code>相对应（作为其配置数据）。</p><p><code>StatelessWidget </code>用于不需要维护状态的场景，它通常在<code>build</code>方法中通过嵌套其它 widget 来构建UI，在构建过程中会递归的构建其嵌套的 widget 。我们看一个简单的例子：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">Echo</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span>  <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token class-name">Echo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token class-name">Key</span><span class="token operator">?</span> key<span class="token punctuation">,</span>  \n    required <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">,</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token class-name">Colors</span><span class="token punctuation">.</span>grey<span class="token punctuation">,</span> <span class="token comment">//默认为灰色</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    \n  <span class="token keyword">final</span> <span class="token class-name">String</span> text<span class="token punctuation">;</span>\n  <span class="token keyword">final</span> <span class="token class-name">Color</span> backgroundColor<span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token class-name">Center</span><span class="token punctuation">(</span>\n      child<span class="token punctuation">:</span> <span class="token class-name">Container</span><span class="token punctuation">(</span>\n        color<span class="token punctuation">:</span> backgroundColor<span class="token punctuation">,</span>\n        child<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码，实现了一个回显字符串的<code>Echo</code> widget 。</p><blockquote><p>按照惯例，widget 的构造函数参数应使用命名参数，命名参数中的必需要传的参数要添加<code>required</code>关键字，这样有利于静态代码分析器进行检查；在继承 widget 时，第一个参数通常应该是<code>Key</code>。另外，如果 widget 需要接收子 widget ，那么<code>child</code>或<code>children</code>参数通常应被放在参数列表的最后。同样是按照惯例， widget 的属性应尽可能的被声明为<code>final</code>，防止被意外改变。</p></blockquote><p>然后我们可以通过如下方式使用它：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code> <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token class-name">Echo</span><span class="token punctuation">(</span>text<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;hello world&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行后效果如图2-3所示：</p><p><img src="'+p+'" alt="图2-3"></p><h3 id="context" tabindex="-1"><a class="header-anchor" href="#context" aria-hidden="true">#</a> Context</h3><p><code>build</code>方法有一个<code>context</code>参数，它是<code>BuildContext</code>类的一个实例，表示当前 widget 在 widget 树中的上下文，每一个 widget 都会对应一个 context 对象（因为每一个 widget 都是 widget 树上的一个节点）。实际上，<code>context</code>是当前 widget 在 widget 树中位置中执行”相关操作“的一个句柄(handle)，比如它提供了从当前 widget 开始向上遍历 widget 树以及按照 widget 类型查找父级 widget 的方法。下面是在子树中获取父级 widget 的一个示例：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">ContextRoute</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span>  <span class="token punctuation">{</span>\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token class-name">Scaffold</span><span class="token punctuation">(</span>\n      appBar<span class="token punctuation">:</span> <span class="token class-name">AppBar</span><span class="token punctuation">(</span>\n        title<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Context测试&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      body<span class="token punctuation">:</span> <span class="token class-name">Container</span><span class="token punctuation">(</span>\n        child<span class="token punctuation">:</span> <span class="token class-name">Builder</span><span class="token punctuation">(</span>builder<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token comment">// 在 widget 树中向上查找最近的父级`Scaffold`  widget </span>\n          <span class="token class-name">Scaffold</span> scaffold <span class="token operator">=</span> context<span class="token punctuation">.</span>findAncestorWidgetOfExactType<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Scaffold</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token comment">// 直接返回 AppBar的title， 此处实际上是Text(&quot;Context测试&quot;)</span>\n          <span class="token keyword">return</span> <span class="token punctuation">(</span>scaffold<span class="token punctuation">.</span>appBar <span class="token operator">as</span> <span class="token class-name">AppBar</span><span class="token punctuation">)</span><span class="token punctuation">.</span>title<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行后效果如图2-4所示：</p><p><img src="'+c+'" alt="图2-4"></p><blockquote><p><strong>注意</strong>：对于<code>BuildContext</code>读者现在可以先作了解，随着本书后面内容的展开，也会用到 Context 的一些方法，读者可以通过具体的场景对其有个直观的认识。关于<code>BuildContext</code>更多的内容，我们也将在后面高级部分再深入介绍。</p></blockquote><h2 id="_2-2-5-statefulwidget" tabindex="-1"><a class="header-anchor" href="#_2-2-5-statefulwidget" aria-hidden="true">#</a> 2.2.5 StatefulWidget</h2><p>和<code>StatelessWidget </code>一样，<code>StatefulWidget</code>也是继承自<code>widget</code>类，并重写了<code>createElement() </code>方法，不同的是返回的<code>Element</code> 对象并不相同；另外<code>StatefulWidget</code>类中添加了一个新的接口<code>createState()</code>。</p><p>下面我们看看<code>StatefulWidget</code>的类定义：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">StatefulWidget</span> <span class="token keyword">extends</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token class-name">StatefulWidget</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token class-name">Key</span> key <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    \n  <span class="token metadata function">@override</span>\n  <span class="token class-name">StatefulElement</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">StatefulElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    \n  <span class="token metadata function">@protected</span>\n  <span class="token class-name">State</span> <span class="token function">createState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>StatefulElement </code> 间接继承自<code>Element</code>类，与<code>StatefulWidget</code>相对应（作为其配置数据）。<code>StatefulElement </code>中可能会多次调用<code>createState()</code>来创建状态（State）对象。</p></li><li><p><code>createState()</code> 用于创建和 StatefulWidget 相关的状态，它在StatefulWidget 的生命周期中可能会被多次调用。例如，当一个 StatefulWidget 同时插入到 widget 树的多个位置时，Flutter 框架就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个<code>StatefulElement</code>对应一个State实例。</p><blockquote><p>而在StatefulWidget 中，State 对象和<code>StatefulElement</code>具有一一对应的关系，所以在Flutter的SDK文档中，可以经常看到“从树中移除 State 对象”或“插入 State 对象到树中”这样的描述，此时的树指通过 widget 树生成的 Element 树。Flutter 的 SDK 文档中经常会提到“树” ，我们可以根据语境来判断到底指的是哪棵树。其实，无论是哪棵树，最终的目标都是为了描述 UI 的结构和绘制信息，所以在 Flutter 中遇到“树”的概念时，若无特别说明，我们都可以理解为 “一棵构成用户界面的节点树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”。</p></blockquote></li></ul><h2 id="_2-2-6-state" tabindex="-1"><a class="header-anchor" href="#_2-2-6-state" aria-hidden="true">#</a> 2.2.6 State</h2><p>一个 StatefulWidget 类会对应一个 State 类，State表示与其对应的 StatefulWidget 要维护的状态，State 中的保存的状态信息可以：</p><ol><li>在 widget 构建时可以被同步读取。</li><li>在 widget 生命周期中可以被改变，当State被改变时，可以手动调用其<code>setState()</code>方法通知Flutter 框架状态发生改变，Flutter 框架在收到消息后，会重新调用其<code>build</code>方法重新构建 widget 树，从而达到更新UI的目的。</li></ol><p>State 中有两个常用属性：</p><ol><li><p><code>widget</code>，它表示与该 State 实例关联的 widget 实例，由Flutter 框架动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的 widget 实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果 widget 被修改了，Flutter 框架会动态设置State. widget 为新的 widget 实例。</p></li><li><p><code>context</code>。StatefulWidget对应的 BuildContext，作用同StatelessWidget 的BuildContext。</p></li></ol><h4 id="state生命周期" tabindex="-1"><a class="header-anchor" href="#state生命周期" aria-hidden="true">#</a> State生命周期</h4><p>理解State的生命周期对flutter开发非常重要，为了加深读者印象，本节我们通过一个实例来演示一下 State 的生命周期。在接下来的示例中，我们仍然以计数器功能为例，实现一个计数器 CounterWidget 组件 ，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">CounterWidget</span> <span class="token keyword">extends</span> <span class="token class-name">StatefulWidget</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token class-name">CounterWidget</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Key</span><span class="token operator">?</span> key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>initValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">final</span> int initValue<span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  _CounterWidgetState <span class="token function">createState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">_CounterWidgetState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>CounterWidget </code>接收一个<code>initValue</code>整型参数，它表示计数器的初始值。下面我们看一下State的代码：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> _CounterWidgetState <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">CounterWidget</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>\n  int _counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">//初始化状态</span>\n    _counter <span class="token operator">=</span> widget<span class="token punctuation">.</span>initValue<span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;initState&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;build&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token class-name">Scaffold</span><span class="token punctuation">(</span>\n      body<span class="token punctuation">:</span> <span class="token class-name">Center</span><span class="token punctuation">(</span>\n        child<span class="token punctuation">:</span> <span class="token class-name">TextButton</span><span class="token punctuation">(</span>\n          child<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;</span><span class="token interpolation"><span class="token punctuation">$</span><span class="token expression">_counter</span></span><span class="token string">&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          <span class="token comment">//点击后计数器自增</span>\n          onPressed<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">setState</span><span class="token punctuation">(</span>\n            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">++</span>_counter<span class="token punctuation">,</span>\n          <span class="token punctuation">)</span><span class="token punctuation">,</span>\n        <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">didUpdateWidget</span><span class="token punctuation">(</span><span class="token class-name">CounterWidget</span> oldWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">didUpdateWidget</span><span class="token punctuation">(</span>oldWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;didUpdateWidget &quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">deactivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;deactivate&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;dispose&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">reassemble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">reassemble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;reassemble&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">didChangeDependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">didChangeDependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;didChangeDependencies&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们创建一个新路由，在新路由中，我们只显示一个<code>CounterWidget </code>：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">StateLifecycleTest</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token class-name">StateLifecycleTest</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Key</span><span class="token operator">?</span> key<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token class-name">CounterWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>I/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: initState\nI/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: didChangeDependencies\nI/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: build\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在StatefulWidget插入到 widget 树时首先<code>initState</code>方法会被调用。</p><p>然后我们点击⚡️按钮热重载，控制台输出日志如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>I/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: reassemble\nI/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: didUpdateWidget \nI/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: build\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到此时<code> initState</code> 和<code>didChangeDependencies</code>都没有被调用，而此时<code>didUpdateWidget </code>被调用。</p><p>接下来，我们在 widget 树中移除<code>CounterWidget </code>，将 StateLifecycleTest 的 <code>build </code>方法改为：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code> <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//移除计数器 </span>\n  <span class="token comment">//return CounterWidget ();</span>\n  <span class="token comment">//随便返回一个Text()</span>\n  <span class="token keyword">return</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;xxx&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后热重载，日志如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>I/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: reassemble\nI/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: deactive\nI/flutter <span class="token punctuation">(</span> <span class="token number">5436</span><span class="token punctuation">)</span>: dispose\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，在<code>CounterWidget </code>从 widget 树中移除时，<code>deactive</code>和<code>dispose</code>会依次被调用。</p><p>下面我们来看看各个回调函数：</p><ul><li><p><code>initState</code>：当 widget 第一次插入到 widget 树时会被调用，对于每一个State对象，Flutter 框架只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>（该方法用于在 widget 树上获取离当前 widget 最近的一个父级<code>InheritedWidget</code>，关于<code>InheritedWidget</code>我们将在后面章节介绍），原因是在初始化完成后， widget 树中的<code>InheritFrom widget </code>也可能会发生变化，所以正确的做法应该在在<code>build（）</code>方法或<code>didChangeDependencies()</code>中调用它。</p></li><li><p><code>didChangeDependencies()</code>：当State对象的依赖发生变化时会被调用；例如：在之前<code>build()</code> 中包含了一个<code>InheritedWidget </code> （第七章介绍），然后在之后的<code>build()</code> 中<code>Inherited widget </code>发生了变化，那么此时<code>InheritedWidget </code>的子 widget 的<code>didChangeDependencies()</code>回调都会被调用。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter 框架会通知 widget 调用此回调。需要注意，组件第一次被创建后挂载的时候（包括重创建）对应的<code>didChangeDependencies</code>也会被调用。</p></li><li><p><code>build()</code>：此回调读者现在应该已经相当熟悉了，它主要是用于构建 widget 子树的，会在如下场景被调用：</p><ol><li>在调用<code>initState()</code>之后。</li><li>在调用<code>didUpdateWidget()</code>之后。</li><li>在调用<code>setState()</code>之后。</li><li>在调用<code>didChangeDependencies()</code>之后。</li><li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。</li></ol></li><li><p><code>reassemble()</code>：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</p></li><li><p><code>didUpdateWidget ()</code>：在 widget 重新构建时，Flutter 框架会调用<code> widget.canUpdate</code>来检测 widget 树中同一位置的新旧节点，然后决定是否需要更新，如果<code> widget.canUpdate</code>返回<code>true</code>则会调用此回调。正如之前所述，<code> widget.canUpdate</code>会在新旧 widget 的 <code>key</code> 和 <code>runtimeType</code> 同时相等时会返回true，也就是说在在新旧 widget 的key和runtimeType同时相等时<code>didUpdateWidget()</code>就会被调用。</p></li><li><p><code>deactivate()</code>：当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter 框架会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用<code>dispose()</code>方法。</p></li><li><p><code>dispose()</code>：当 State 对象从树中被永久移除时调用；通常在此回调中释放资源。</p></li></ul><p>StatefulWidget 生命周期如图2-5所示：</p><p><img src="'+o+'" alt="图2-5"></p><blockquote><p><strong>注意</strong>：在继承<code>StatefulWidget</code>重写其方法时，对于包含<code>@mustCallSuper</code>标注的父类方法，都要在子类方法中调用父类方法。</p></blockquote><h2 id="_2-2-7-在-widget-树中获取state对象" tabindex="-1"><a class="header-anchor" href="#_2-2-7-在-widget-树中获取state对象" aria-hidden="true">#</a> 2.2.7 在 widget 树中获取State对象</h2><p>由于 StatefulWidget 的的具体逻辑都在其 State 中，所以很多时候，我们需要获取 StatefulWidget 对应的State 对象来调用一些方法，比如<code>Scaffold</code>组件对应的状态类<code>ScaffoldState</code>中就定义了打开 SnackBar（路由页底部提示条）的方法。我们有两种方法在子 widget 树中获取父级 StatefulWidget 的State 对象。</p><h3 id="通过context获取" tabindex="-1"><a class="header-anchor" href="#通过context获取" aria-hidden="true">#</a> 通过Context获取</h3><p><code>context</code>对象有一个<code>findAncestorStateOfType()</code>方法，该方法可以从当前节点沿着 widget 树向上查找指定类型的 StatefulWidget 对应的 State 对象。下面是实现打开 SnackBar 的示例：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">GetStateObjectRoute</span> <span class="token keyword">extends</span> <span class="token class-name">StatefulWidget</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token class-name">GetStateObjectRoute</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">Key</span><span class="token operator">?</span> key<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">State</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GetStateObjectRoute</span><span class="token punctuation">&gt;</span></span> <span class="token function">createState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">_GetStateObjectRouteState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> _GetStateObjectRouteState <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">GetStateObjectRoute</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">Widget</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token class-name">Scaffold</span><span class="token punctuation">(</span>\n      appBar<span class="token punctuation">:</span> <span class="token class-name">AppBar</span><span class="token punctuation">(</span>\n        title<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;子树中获取State对象&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      body<span class="token punctuation">:</span> <span class="token class-name">Center</span><span class="token punctuation">(</span>\n        child<span class="token punctuation">:</span> <span class="token class-name">Column</span><span class="token punctuation">(</span>\n          children<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n            <span class="token class-name">Builder</span><span class="token punctuation">(</span>builder<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n              <span class="token keyword">return</span> <span class="token class-name">ElevatedButton</span><span class="token punctuation">(</span>\n                onPressed<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                  <span class="token comment">// 查找父级最近的Scaffold对应的ScaffoldState对象</span>\n                  <span class="token class-name">ScaffoldState</span> _state <span class="token operator">=</span> context<span class="token punctuation">.</span>findAncestorStateOfType<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ScaffoldState</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">;</span>\n                  <span class="token comment">// 打开抽屉菜单</span>\n                  _state<span class="token punctuation">.</span><span class="token function">openDrawer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n                <span class="token punctuation">}</span><span class="token punctuation">,</span>\n                child<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;打开抽屉菜单1&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n              <span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          <span class="token punctuation">]</span><span class="token punctuation">,</span>\n        <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      drawer<span class="token punctuation">:</span> <span class="token class-name">Drawer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说，如果 StatefulWidget 的状态是私有的（不应该向外部暴露），那么我们代码中就不应该去直接获取其 State 对象；如果StatefulWidget的状态是希望暴露出的（通常还有一些组件的操作方法），我们则可以去直接获取其State对象。但是通过 <code>context.findAncestorStateOfType</code> 获取 StatefulWidget 的状态的方法是通用的，我们并不能在语法层面指定 StatefulWidget 的状态是否私有，所以在 Flutter 开发中便有了一个默认的约定：如果 StatefulWidget 的状态是希望暴露出的，应当在 StatefulWidget 中提供一个<code>of</code> 静态方法来获取其 State 对象，开发者便可直接通过该方法来获取；如果 State不希望暴露，则不提供<code>of</code>方法。这个约定在 Flutter SDK 里随处可见。所以，上面示例中的<code>Scaffold</code>也提供了一个<code>of</code>方法，我们其实是可以直接调用它的：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token class-name">Builder</span><span class="token punctuation">(</span>builder<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token class-name">ElevatedButton</span><span class="token punctuation">(</span>\n    onPressed<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 直接通过of静态方法来获取ScaffoldState</span>\n      <span class="token class-name">ScaffoldState</span> _state<span class="token operator">=</span><span class="token class-name">Scaffold</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token comment">// 打开抽屉菜单</span>\n      _state<span class="token punctuation">.</span><span class="token function">openDrawer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    child<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;打开抽屉菜单2&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>又比如我们想显示 snack bar 的话可以通过下面代码调用：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token class-name">Builder</span><span class="token punctuation">(</span>builder<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token class-name">ElevatedButton</span><span class="token punctuation">(</span>\n    onPressed<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token class-name">ScaffoldMessenger</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">showSnackBar</span><span class="token punctuation">(</span>\n        <span class="token class-name">SnackBar</span><span class="token punctuation">(</span>content<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;我是SnackBar&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    child<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;显示SnackBar&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面示例运行后，点击”显示SnackBar“，效果如图2-6所示：</p><p><img src="'+l+'" alt="图2-6"></p><h3 id="通过globalkey" tabindex="-1"><a class="header-anchor" href="#通过globalkey" aria-hidden="true">#</a> 通过GlobalKey</h3><p>Flutter还有一种通用的获取<code>State</code>对象的方法——通过GlobalKey来获取！ 步骤分两步：</p><ol><li><p>给目标<code>StatefulWidget</code>添加<code>GlobalKey</code>。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token comment">//定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储</span>\n<span class="token keyword">static</span> <span class="token class-name">GlobalKey</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ScaffoldState</span><span class="token punctuation">&gt;</span></span> _globalKey<span class="token operator">=</span> <span class="token class-name">GlobalKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token class-name">Scaffold</span><span class="token punctuation">(</span>\n    key<span class="token punctuation">:</span> _globalKey <span class="token punctuation">,</span> <span class="token comment">//设置key</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  \n<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过<code>GlobalKey</code>来获取<code>State</code>对象</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code>_globalKey<span class="token punctuation">.</span>currentState<span class="token punctuation">.</span><span class="token function">openDrawer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>GlobalKey 是 Flutter 提供的一种在整个 App 中引用 element 的机制。如果一个 widget 设置了<code>GlobalKey</code>，那么我们便可以通过<code>globalKey.currentWidget </code>获得该 widget 对象、<code>globalKey.currentElement</code>来获得 widget 对应的element对象，如果当前 widget 是<code>StatefulWidget</code>，则可以通过<code>globalKey.currentState</code>来获得该 widget 对应的state对象。</p><blockquote><p>注意：使用 GlobalKey 开销较大，如果有其他可选方案，应尽量避免使用它。另外，同一个 GlobalKey 在整个 widget 树中必须是唯一的，不能重复。</p></blockquote><h2 id="_2-2-8-通过-renderobject-自定义-widget" tabindex="-1"><a class="header-anchor" href="#_2-2-8-通过-renderobject-自定义-widget" aria-hidden="true">#</a> 2.2.8 通过 RenderObject 自定义 Widget</h2><p><code>StatelessWidget</code> 和 <code>StatefulWidget</code> 都是用于组合其它组件的，它们本身没有对应的 RenderObject。Flutter 组件库中的很多基础组件都不是通过<code>StatelessWidget</code> 和 <code>StatefulWidget</code> 来实现的，比如 Text 、Column、Align等，就好比搭积木，<code>StatelessWidget</code> 和 <code>StatefulWidget</code> 可以将积木搭成不同的样子，但前提是得有积木，而这些积木都是通过自定义 RenderObject 来实现的。实际上Flutter 最原始的定义组件的方式就是通过定义RenderObject 来实现，而<code>StatelessWidget</code> 和 <code>StatefulWidget</code> 只是提供的两个帮助类。下面我们简单演示一下通过RenderObject定义组件的方式：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">class</span> <span class="token class-name">CustomWidget</span> <span class="token keyword">extends</span> <span class="token class-name">LeafRenderObjectWidget</span><span class="token punctuation">{</span>\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">RenderObject</span> <span class="token function">createRenderObject</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 创建 RenderObject</span>\n    <span class="token keyword">return</span> <span class="token class-name">RenderCustomObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">updateRenderObject</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">,</span> <span class="token class-name">RenderCustomObject</span>  renderObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 更新 RenderObject</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">updateRenderObject</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> renderObject<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">RenderCustomObject</span> <span class="token keyword">extends</span> <span class="token class-name">RenderBox</span><span class="token punctuation">{</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">performLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 实现布局逻辑</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token keyword">void</span> <span class="token function">paint</span><span class="token punctuation">(</span><span class="token class-name">PaintingContext</span> context<span class="token punctuation">,</span> <span class="token class-name">Offset</span> offset<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 实现绘制</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果组件不会包含子组件，则我们可以直接继承自 LeafRenderObjectWidget ，它是 RenderObjectWidget 的子类，而 RenderObjectWidget 继承自 Widget ，我们可以看一下它的实现：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LeafRenderObjectWidget</span> <span class="token keyword">extends</span> <span class="token class-name">RenderObjectWidget</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token class-name">LeafRenderObjectWidget</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token class-name">Key</span><span class="token operator">?</span> key <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">super</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token metadata function">@override</span>\n  <span class="token class-name">LeafRenderObjectElement</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token class-name">LeafRenderObjectElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很简单，就是帮 widget 实现了createElement 方法，它会为组件创建一个 类型为 LeafRenderObjectElement 的 Element对象。如果自定义的 widget 可以包含子组件，则可以根据子组件的数量来选择继承SingleChildRenderObjectWidget 或 MultiChildRenderObjectWidget，它们也实现了createElement() 方法，返回不同类型的 Element 对象。</p><p>然后我们重写了 createRenderObject 方法，它是 RenderObjectWidget 中定义方法，该方法被组件对应的 Element 调用（构建渲染树时）用于生成渲染对象。我们的主要任务就是来实现 createRenderObject 返回的渲染对象类，本例中是 RenderCustomObject 。updateRenderObject 方法是用于在组件树状态发生变化但不需要重新创建 RenderObject 时用于更新组件渲染对象的回调。</p><p>RenderCustomObject 类是继承自 RenderBox，而 RenderBox 继承自 RenderObject，我们需要在 RenderCustomObject 中实现布局、绘制、事件响应等逻辑，关于如何实现这些逻辑，涉及到的知识点会贯穿本书，现在先不要着急，我们会在后面的章节中逐步介绍。</p><h2 id="_2-2-9-flutter-sdk内置组件库介绍" tabindex="-1"><a class="header-anchor" href="#_2-2-9-flutter-sdk内置组件库介绍" aria-hidden="true">#</a> 2.2.9 Flutter SDK内置组件库介绍</h2><p>Flutter 提供了一套丰富、强大的基础组件，在基础组件库之上 Flutter 又提供了一套 Material 风格（ Android 默认的视觉风格）和一套 Cupertino 风格（iOS视觉风格）的组件库。要使用基础组件库，需要先导入：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;package:flutter/widgets.dart&#39;</span></span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面我们介绍一下常用的组件。</p><h4 id="基础组件" tabindex="-1"><a class="header-anchor" href="#基础组件" aria-hidden="true">#</a> 基础组件</h4>',101),d={href:"https://docs.flutter.io/flutter/widgets/Text-class.html",target:"_blank",rel:"noopener noreferrer"},r=(0,e._)("code",null,"Text",-1),k={href:"https://docs.flutter.io/flutter/widgets/Row-class.html",target:"_blank",rel:"noopener noreferrer"},v=(0,e._)("code",null,"Row",-1),m={href:"https://docs.flutter.io/flutter/widgets/Column-class.html",target:"_blank",rel:"noopener noreferrer"},g=(0,e._)("code",null,"Column",-1),b={href:"https://docs.flutter.io/flutter/widgets/Stack-class.html",target:"_blank",rel:"noopener noreferrer"},f=(0,e._)("code",null,"Stack",-1),h=(0,e._)("code",null,"FrameLayout",-1),w=(0,e._)("code",null,"Stack",-1),S={href:"https://docs.flutter.io/flutter/widgets/Positioned-class.html",target:"_blank",rel:"noopener noreferrer"},y=(0,e._)("code",null,"Positioned",-1),W=(0,e._)("code",null,"Stack",-1),x={href:"https://docs.flutter.io/flutter/widgets/Container-class.html",target:"_blank",rel:"noopener noreferrer"},_=(0,e._)("code",null,"Container",-1),C={href:"https://docs.flutter.io/flutter/widgets/Container-class.html",target:"_blank",rel:"noopener noreferrer"},R=(0,e._)("code",null,"Container",-1),O={href:"https://docs.flutter.io/flutter/painting/BoxDecoration-class.html",target:"_blank",rel:"noopener noreferrer"},j=(0,e._)("code",null,"BoxDecoration",-1),E={href:"https://docs.flutter.io/flutter/widgets/Container-class.html",target:"_blank",rel:"noopener noreferrer"},B=(0,e._)("code",null,"Container",-1),U={href:"https://docs.flutter.io/flutter/widgets/Container-class.html",target:"_blank",rel:"noopener noreferrer"},T=(0,e._)("code",null,"Container",-1),F=(0,e._)("h4",{id:"material组件",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#material组件","aria-hidden":"true"},"#"),(0,e.Uk)(" Material组件")],-1),q={href:"https://docs.flutter.io/flutter/material/MaterialApp-class.html",target:"_blank",rel:"noopener noreferrer"},K=(0,e._)("code",null,"MaterialApp",-1),I=(0,e._)("code",null,"Theme",-1),D={href:"https://docs.flutter.io/flutter/material/MaterialApp-class.html",target:"_blank",rel:"noopener noreferrer"},A=(0,e._)("code",null,"MaterialApp",-1),G=(0,e._)("code",null,"Scaffold",-1),P=(0,e._)("code",null,"AppBar",-1),L=(0,e._)("code",null,"TextButton",-1),M=(0,e.uE)('<div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;package:flutter/material.dart&#39;</span></span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="cupertino组件" tabindex="-1"><a class="header-anchor" href="#cupertino组件" aria-hidden="true">#</a> Cupertino组件</h4><p>Flutter 也提供了一套丰富的 Cupertino 风格的组件，尽管目前还没有 Material 组件那么丰富，但是它仍在不断的完善中。值得一提的是在 Material 组件库中有一些组件可以根据实际运行平台来切换表现风格，比如<code>MaterialPageRoute</code>，在路由切换时，如果是 Android 系统，它将会使用 Android 系统默认的页面切换动画(从底向上)；如果是 iOS 系统，它会使用 iOS 系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino组件的示例，下面我们实现一个简单的 Cupertino 组件风格的页面：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token comment">//导入cupertino  widget 库</span>\n<span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;package:flutter/cupertino.dart&#39;</span></span><span class="token punctuation">;</span>\n\n<span class="token keyword">class</span> <span class="token class-name">CupertinoTestRoute</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span>  <span class="token punctuation">{</span>\n  <span class="token metadata function">@override</span>\n  widget <span class="token function">build</span><span class="token punctuation">(</span><span class="token class-name">BuildContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token class-name">CupertinoPageScaffold</span><span class="token punctuation">(</span>\n      navigationBar<span class="token punctuation">:</span> <span class="token class-name">CupertinoNavigationBar</span><span class="token punctuation">(</span>\n        middle<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Cupertino Demo&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      child<span class="token punctuation">:</span> <span class="token class-name">Center</span><span class="token punctuation">(</span>\n        child<span class="token punctuation">:</span> <span class="token class-name">CupertinoButton</span><span class="token punctuation">(</span>\n            color<span class="token punctuation">:</span> <span class="token class-name">CupertinoColors</span><span class="token punctuation">.</span>activeBlue<span class="token punctuation">,</span>\n            child<span class="token punctuation">:</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Press&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            onPressed<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n        <span class="token punctuation">)</span><span class="token punctuation">,</span>\n      <span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面（图2-7）是在iPhoneX上页面效果截图：</p><p><img src="'+i+'" alt="图2-7"></p><h3 id="关于示例" tabindex="-1"><a class="header-anchor" href="#关于示例" aria-hidden="true">#</a> 关于示例</h3><p>本章后面章节的示例中会使用一些布局类组件，如<code>Scaffold</code>、<code>Row</code>、<code>Column</code>等，这些组件将在后面“布局类组件”一章中详细介绍，读者可以先不用关注。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>Flutter 提供了丰富的组件，在实际的开发中我们可以根据需要随意使用它们，而不必担心引入过多组件库会让你的应用安装包变大，这不是 web 开发，dart 在编译时只会编译你使用了的代码。由于 Material 和Cupertino 都是在基础组件库之上的，所以如果我们的应用中引入了这两者之一，则不需要再引入<code>flutter/ widgets.dart</code>了，因为它们内部已经引入过了。</p>',10),V={},z=(0,a(18580).Z)(V,[["render",function(n,s){const a=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)("div",null,[u,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("a",d,[r,(0,e.Wm)(a)]),(0,e.Uk)("：该组件可让您创建一个带格式的文本。")]),(0,e._)("li",null,[(0,e._)("a",k,[v,(0,e.Wm)(a)]),(0,e.Uk)("、 "),(0,e._)("a",m,[g,(0,e.Wm)(a)]),(0,e.Uk)("： 这些具有弹性空间的布局类 widget 可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于 Web 开发中的 Flexbox 布局模型。")]),(0,e._)("li",null,[(0,e._)("a",b,[f,(0,e.Wm)(a)]),(0,e.Uk)("： 取代线性布局 (译者语：和 Android 中的"),h,(0,e.Uk)("相似)，["),w,(0,e.Uk)("](https://docs.flutter.io/flutter/ widgets/Stack-class.html)允许子 widget 堆叠， 你可以使用 "),(0,e._)("a",S,[y,(0,e.Wm)(a)]),(0,e.Uk)(" 来定位他们相对于"),W,(0,e.Uk)("的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。")]),(0,e._)("li",null,[(0,e._)("a",x,[_,(0,e.Wm)(a)]),(0,e.Uk)("： "),(0,e._)("a",C,[R,(0,e.Wm)(a)]),(0,e.Uk)(" 可让您创建矩形视觉元素。Container 可以装饰一个"),(0,e._)("a",O,[j,(0,e.Wm)(a)]),(0,e.Uk)(", 如 background、一个边框、或者一个阴影。 "),(0,e._)("a",E,[B,(0,e.Wm)(a)]),(0,e.Uk)(" 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， "),(0,e._)("a",U,[T,(0,e.Wm)(a)]),(0,e.Uk)("可以使用矩阵在三维空间中对其进行变换。")])]),F,(0,e._)("p",null,[(0,e.Uk)("Flutter 提供了一套丰富 的Material 组件，它可以帮助我们构建遵循 Material Design 设计规范的应用程序。Material 应用程序以"),(0,e._)("a",q,[K,(0,e.Wm)(a)]),(0,e.Uk)(" 组件开始， 该组件在应用程序的根部创建了一些必要的组件，比如"),I,(0,e.Uk)("组件，它用于配置应用的主题。 是否使用"),(0,e._)("a",D,[A,(0,e.Wm)(a)]),(0,e.Uk)("完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个 Material 组件了，如："),G,(0,e.Uk)("、"),P,(0,e.Uk)("、"),L,(0,e.Uk)("等。要使用 Material 组件，需要先引入它：")]),M])}]])},18580:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);